<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui">
  <title>FRAC - PLT Project Proposal</title>
  <link rel="stylesheet" href="github-markdown.css">
  <style>body{min-width:200px;max-width:790px;margin:0 auto;padding:30px;}</style>
</head>

<body>
<article class="markdown-body">
  <h1>FRAC: Recursive Art Compiler</h1>
    <p><i>COMS W4115 - Language Proposal</i></p>
    <p><i>September 30, 2015</i></p>

  <h2>Team</h2>
  <ul>
    <li><strong>Anne Zhang </strong><code>az2350</code> - Manager</li>
    <li><strong>Kunal Kamath </strong><code>kak2211</code> - Language Guru</li>
    <li><strong>Justin Chiang </strong><code>jc4127</code> - Systems Architect</li>
    <li><strong>Calvin Li </strong><code>ctl2124</code> - Tester</li>
  </ul>

  <h2>Description</h2>
    <p>FRAC enables a programmer to generate fractals in the Graphics Interchange Format, commonly abbreviated as GIF. Specifically, the user will be able to program a fractal using a formal grammar, as well as incorporate algorithms into their fractal generation.</p>
    <p>We define our fractal-generating grammars as:</p>
      <div class="highlight highlight-js"><pre>G = (init, rules)</pre></div>
    <p>where,</p>
      <ul>
        <li><strong>init:</strong> a string that defines the initial state of the system</li>
        <li><strong>rules:</strong> a set of rules that defines the way variables are replaced with combinations of variables and movements during the recursion. Each rule has two halves to it, separated by an arrow (→). There are two types of rules: recursive rules, which point to a string, and terminal rules, which point to a function</li>
      </ul>


  <h2>Syntax</h2>
    <h3>Declaration/Assignment</h3>
      <p>Variables are declared and assigned in the same syntax as C.</p>
      <div class="highlight highlight-js"><pre>int a;
a = 0;
int b = 1;</pre></div>
    <h3>Data Types</h3>
      <ul>
        <li><strong>int:</strong> an integer of 32 bits</li>
        <li><strong>double:</strong> a floating point number of 64 bits</li>
        <li><strong>bool:</strong> a true or false value</li>
        <li><strong>string:</strong> a collection of characters/symbols</li>
        <li><strong>rule:</strong> a standard object composed of 2 fields
          <ul>
            <li>a <i>predecessor</i> string</li>
            <li>a <i>successor</i> string or function</li>
          </ul>
        </li>
        <li><strong>gram:</strong>: a standard object composed of 2 fields
          <ul>
            <li>an <i>init</i> string</li>
            <li>a set called <i>rules</i></li>
          </ul>
        </li>
      </ul>
      <p>e.g. Consider the following grammar declaration:</p>
      <pre>gram G = {
    init: 'X',
    rules: { 'X' → 'X up X down X',
             'up' → turn(90),
             'down' → turn(-90),
             'X' → move(1)
    }
};</pre>
    <h3>Structures</h3>
      <ul>
        <li><strong>primitive:</strong> fundamentally built into the language</li>
        <li><strong>object:</strong> Javascript-like object with (key, value)</li>
        <li><strong>set:</strong> unordered collection of objects or other data types</li>
      </ul>
    <h3>Operators</h3>
      <p>Mathematical and logical operators are the same as in C (e.g. + - * /, && ||, < > ==).</p>
    <h3>Control Flow</h3>
      <p>If/else statements, while loops, and for loops are the same as in Java.</p>
    <h3>Functions</h3>
      <p>Functions have return values and can take parameters. They are defined with the keyword "func", followed by the function name, parameters contained in parentheses and separated by commas, and brackets.</p>
      <pre>func add(a, b) {
    return a + b;
}</pre>
    <h3>Built-in Functions</h3>
      <ul>
        <li><strong>main</strong> () - entry point upon which program executes</li>
        <li><strong>move</strong> (int len) - draws a line of length len. Implements turtle graphics, which graphs line segments based on a given orientation and relative position</li>
        <li><strong>turn</strong> (int theta) - Turns the turtle's orientation by an angle of theta (degrees in the polar coordinate system)</li>
        <li><strong>draw</strong> (gram G, int num) - generates a static fractal image. 'num' corresponds to the recursion depth of the grammar, and will indicate how many times the grammar’s ruleset should be applied in the drawing</li>
        <li><strong>grow</strong> (gram G, int num) - generates a GIF of the fractal being created at each recursive step</li>
        <li><strong>zoom</strong> (gram G, int num) - generates a (seemingly infinite) zooming GIF of the fractal</li>
      </ul>
    <h3>Comments</h3>
      <p>Just like in Java, // for single line and /* */ for multi line comments.</p>


  <h2>Proposed Applications</h2>
    <p>Since FRAC makes visualizing fractals and other iterative shapes simple, we see it being quite useful to mathematicians or curious students who wish to explore the world of recursive images with minimal programming experience. Furthermore, the ability to create GIFs with FRAC will result in not only the spread of fractal art, but will also help visual learners better understand the concept of the self-similar pattern.</p>
    <p>Additionally, because FRAC also supports Java-like control flow in addition to fractal-specific methods, users have the opportunity to algorithmically manipulate fractals. See sample program #2.</p>


  <h2>Sample Programs</h2>

    <h3>Generate a static image of the Koch snowflake</h3>
  <div class="highlight highlight-js"><pre>/*
 * See https://en.wikipedia.org/wiki/Koch_snowflake for reference
 */

gram koch = {
    init: 'F r r F r r F',
    rules: { 'F' → 'F l F r r F l F',
             'r' → turn(60),
             'l' → turn(-60),
             'F' → move(1)
    }
};

main() {
    draw(koch, 4);
}</pre></div>
<h4>Expected output:</h4>
<img src="snowflake.png" style="width:256px;height:256px;">

<h3>Polyzygotic snowflakes</h3>
<div class="highlight highlight-js"><pre>/*
 * Uses the ability to access object properties to create
 * conjoined twins, triplets, etc. of your desired fractal!
 */

gram koch = {
  init: 'F r r F r r F',
  rules: { 'F' → 'F l F r r F l F',
    'r' → turn(60),
    'l' → turn(-60),
    'F' → move(1)
  }
};

func twin(gram g, int n) {
    string new_init = '';
    for(int i = 0; i < n; i++) {
      new_init = new_init + g.init;
    }
    g.init = new_init;
    return g;
}

main() {
  draw(twin(koch, 3), 4);
}</pre></div>
<h4>Expected output:</h4>
<img src="triplet-snowflake.png" style="width:256px;height:256px;">

</article>
</body>
</html>
