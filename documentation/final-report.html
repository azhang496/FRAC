<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui">
  <title>FRAC - Final Report</title>
  <link rel="stylesheet" href="markdown.css">
  <style>body{min-width:200px;max-width:790px;margin:0 auto;padding:30px;}</style>
</head>

<body>
<article class="markdown-body">
  <h1>FRAC: Recursive Art Compiler</h1>
    <ul>
      <li><strong>Anne Zhang </strong><code>az2350</code></li>
      <li><strong>Kunal Kamath </strong><code>kak2211</code></li>   
      <li><strong>Calvin Li </strong><code>ctl2124</code></li>
      <li><strong>Justin Chiang </strong><code>jc4127</code></li>

    </ul>

  <h2>1. Introduction</h2>
    <p>FRAC is a domain-specific programming language that enables the programmer to generate fractals in the form of bitmap image files (BMPs). The language is meant for those interested in the mathematical manipulation of recursively generated images like fractals. We designed this language to be simple, intuitive, and a joy to use!</p>
    <p>Our language uses the L-system method, which uses grammars (similar to those we learned in COMS W3261) to generate fractals. A basic FRAC program is composed of function and grammar declarations. A call to the <code>draw(gram g, int n)</code> system function from within any function in the program will generate a BMP image from the specified grammar g. The integer n specifies how many times the recursive rules defined in g are evaluated, which affects the size and complexity of the generated fractal.

  <h2>2. Language Tutorial</h2>
    <h3>2.1 Compiling and Running</h3>
    <p>Run <code>make</code> in the top level directory of our source code to compile the <code>frac</code> compiler.  Then, simply run the shell script <code>gen.sh</code> with a filename argument to compile and run your FRAC code. The filename must have extension .frac.</p>
    <div class="highlight highlight-js"><pre>$ ./gen.sh test.frac</pre></div>
    <p>If your FRAC program generates an image, it requires the turtle graphics C library (the <code>turtle.h</code> and <code>turtle.c</code> files). Additionally, if you are using the <code>grow()</code> function to generate an animated GIF, it requires the [SOMETHING] library. All of these files are included in our source code directory, and our shell script compiles and links them as necessary.</p>

    <h3>2.3 Writing a FRAC Program</h3>
    

    <h3>2.2 Example Programs</h3>
      <h4>2.2.1 Hello World</h4>
      <p>This simple program prints "hello world":</p>
      <div class="highlight highlight-js"><pre>main() {
      print("hello world");
}</pre></div>
      <h4>2.2.2 GCD</h4>
      <p>This program calculates and prints the greatest common divisor (GCD) of 8 and 12:</p>
      <div class="highlight highlight-js"><pre>gcd(int x, int y) {
    while(x != y) {
        if(x > y) {
          a = a-b;
        }
        else {
            b = b-a;
        }
    }
    return a;
}

main() {
    int n = gcd(8, 12);
    print(n);
}</pre></div>
      <h4>2.2.3 Koch Snowflake</h4>
      <p>As our language is designed to facilitate generation of fractals, the best way to program in FRAC is to define grammars and draw them! For example, you can create a Koch snowflake using the following FRAC program:</p>
      <div class="highlight highlight-js"><pre>gram koch = {
    alphabet: [F, p, m],
    init: 'F p p F p p F',
    rules: {
        'F' -> 'F m F p p F m F',
        'F' -> move(1),
        'm' -> rturn(60),
        'p' -> lturn(60)
    }
}

main() {
    draw(koch, 6);
}</pre></div>
      <img src="koch.bmp" style="width:256px;height:280px;">
      <h4>2.2.4 Sierpinski Triangle</h4>
      <p>Another fun fractal is the Sierpinski triangle. The grammar for generating a Sierpinski triangle is somewhat more complex than the Koch snowflake (but still easy to write!):</p>
      <div class="highlight highlight-js"><pre>gram sierp = {
    alphabet: [A, B, p, m],
    init: 'A',
    rules: {
        'A' -> 'p B m A m B p',
        'A' -> move(1),
        'B' -> 'm A p B p A m',
        'B' -> move(1),
        'p' -> lturn(60),
        'm' -> rturn(60)
    }
}

main() {
    draw(sierp, 9);
}</pre></div>
      <img src="sierp.bmp" style="width:290px;height:256px;">

  <h2>2. Data Types & Data Structures</h2>
      <p>The language supports two categories of data types: primitive types and complex types.</p>
      <h3>2.1 Primitive types</h3>
      <p>A primitive type requires a small and fixed amount of memory to store a single logical value. Typical primitive types include <code>int</code>, <code>double</code>, and <code>bool</code>. One exception is <code>string</code>, which requires a variable amount of memory storage.</p>
      <p>Explicit and implicit type conversion between <code>int</code> and <code>double</code> is allowed, but no other type conversions are supported, with the exception of “reflexive conversions” (e.g. converting <code>double</code> to <code>double</code>). Explicit type conversion can be performed with the following syntax:</p>
      <div class="highlight highlight-js"><pre>double x = 3.5;
x = (double) x;  // reflexive conversions are permitted
int y = (int) x;
double z = (double) y;</pre></div>
      <p>Alternatively, omitting the explicit parentheses-enclosed target type produces an identical outcome.</p>
      <div class="highlight highlight-js"><pre>double x = 3.5;
x = x;
int y = x;
double z = y;</pre></div>
      <p>Note that explicit type conversion can operate on both variables and constants. Therefore, the following is permitted:</p>
      <div class="highlight highlight-js"><pre>int a = (int) 3.5;</pre></div>
      <p>Converting a double to an integer results in truncation of the fractional part, while converting an integer to a double results in the addition of a fractional part with a value of zero.</p>
      <p>When performing an arithmetic operation between an integer and a double, the compiler automatically promotes the integer into a double. Thus, the following three statements are operationally equivalent:</p>
      <div class="highlight highlight-js"><pre>double c = 3.5 + 3;  // c is 6.5

double c = 3.5 + (double) 3;  // c is 6.5
double c = 3.5 + 3.0;  // c is 6.5</pre></div>
      <h3>2.2 Complex types</h3>
      <p>A complex type contains multiple named fields and requires a larger and variable amount of memory to store a structured collection of values. A complex type is similar to the familiar object type in so far as it contains fields, but a complex type does not contain any methods. In fact, all instantiated complex types are immutable; operating on them requires the use of functions.</p>
      <p>Two complex types are supported in the language: <code>gram</code> and <code>rule</code>.</p>
      <p>A <code>gram</code> represents a formal grammar that is used to specify a fractal that can be drawn. A <code>rule</code> represents a production rule that is a part of the formal grammar. Later sections expand on how such grammars and rules can be declared in code.</p>
      <p>Just like in Java, // for single line and /* */ for multi line comments.</p>

  <h2>3. Lexical Conventions</h2>
    <h3>3.1 Identifiers</h3>
    <p>An identifier is a sequence of alphanumerics and underscores. An identifier may begin with neither a digit nor an underscore. Both uppercase and lowercase letters are permitted. The following are valid identifiers: <code>kunal_43</code>, <code>hello_ANNIE</code>, and <code>do_this____justin</code>. The following are invalid: <code>helloworld&</code>, <code>_dothis</code>, and <code>4calvin</code>.</p>
    <h3>3.2 Keywords</h3>
    <p>The following are a list of reserved keywords in the language:</p>
    <div class="highlight highlight-js"><pre>rule
gram
func
if
else
while
return
true
false</pre></div>
    <p>as well as the literal types:</p>
    <div class="highlight highlight-js"><pre>int
double
bool
string</pre></div>
    <p>No keyword may be used as an identifier.</p>
    <h3>3.3 Literals</h3>
    <p>A literal is a notation that represents the value itself as written. Literals can only be of one of the primitive types, which are discussed below. A literal may not be used as an identifier.</p>
    <h4>3.3.1 Integer constants</h4>
    <p>An integer consists of a sequence of digits not containing a decimal point.</p>
    <div class="highlight highlight-js"><pre>int x = 10;</pre></div>
    <h4>3.3.2 Floating point constants</h4>
    <p>A floating point constant consists of two sequences of digits, where one may be the empty sequence, separated by a decimal point.</p>
    <div class="highlight highlight-js"><pre>double y = 4.55;</pre></div>
    <h4>3.3.3 Boolean constants</h4>
    <p>There exist only two boolean constants:</p>
    <div class="highlight highlight-js"><pre>bool is_there = true;
bool is_there = false;</pre></div>
    <h4>3.3.4 String constants</h4>
    <p>A string constant consists of a sequence of characters enclosed by single quotes.</p>
    <div class="highlight highlight-js"><pre>string name = 'Anne Zhang’;</pre></div>


    <h3>3.4 Comments</h3>
    <p>Just like in Java, <code>//</code> are used for single line comments and <code>/* */</code> for nested or multi-line comments.</p>
    <div class="highlight highlight-js"><pre>// This is a single line comment
/* This is
   a multi-line
   comment
 */</pre></div>
    <p>In a single line, all characters after <code>//</code> are ignored by the compiler.</p>
    <p>With multi-line comments, the compiler will ignore everything from <code>/*</code> to <code>*/</code>. Note, however, that multi-line comments cannot be nested within one another like so:</p>
    <div class="highlight highlight-js"><pre>/* Multi-line comments
   /* cannot be nested */
   like in this example!
 */</pre></div>
    <p>This will result in a syntax error, as the compiler will treat the first <code>*/</code> as the end of the comment.</p>
    <h3>3.5 Operators</h3>
    <p>Operators specify logical or mathematical operations to be performed.</p>
    <p>Arithmetic operators:<br>
<code>+</code> 	addition<br>
<code>-</code>	subtraction<br>
<code>*</code>	multiplication<br>
<code>/</code>	division<br>
<code>%</code>	modulo</p>
    <p><code>=</code> assignment</p>
    <p>Logical operators:<br>
<code>!</code>	negation<br>
<code>==</code>	equivalence<br>
<code>!=</code>	non-equivalence<br>
<code><</code>	less than<br>
<code>></code>	greater than<br>
<code>&&</code>	AND<br>
<code>||</code>	OR</p>
    <p>The arrow <code>-></code> is a special operator used in rule definitions in grammars.  In a rule, the string to the left of the arrow can be replaced by the string or system function to the right of the arrow.  For example:</p>
    <div class="highlight highlight-js"><pre>'F' -> 'F l F r r F l F',
'r' -> turn(60)</pre></div>
    <p>are both valid rules.  The arrow has no meaning outside of rule definitions, and an error will be thrown if it is used outside of this context.</p>
    <h3>3.6 Punctuators</h3>
    <p><code>;</code>
      <ul><li>terminate statements</li></ul></p>
    <p><code>,</code>
      <ul><li>separate function parameters, separate key-value pairs in grammar definitions</li></ul>
    <p><code>'</code>
      <ul><li>string literal declaration</li></ul>
    <p><code>{}</code>
      <ul><li>grammar definitions</li>
      <li>scope</li></ul>
    <p><code>()</code>
      <ul><li>function arguments</li>
      <li>expression precedence</li>
      <li>type casting</li>
      <li>conditional parameters</li></ul>


  <h2>4. Syntax</h2>
    <h3>4.1 Program Structure</h3>
    <p>FRAC programs should be written in a single file.  A FRAC program consists of grammar definitions, function definitions, and a <code>main()</code> function.  Functions and grammars are defined first and subsequently used in the <code>main()</code> function, although they cannot be defined within the <code>main()</code> function itself.</p>
    <p>The <code>main()</code> function is the entry point for the program.  It may contain variable and literal declarations, expressions, and statements.  It may also use any previously defined functions and grammars.  In addition, the <code>main()</code> function must use one, and only one, of the following system functions: <code>draw()</code>, <code>grow()</code>.  This function specifies the type of image output that the program will create.</p>
    <p>The following is an example of a valid FRAC program:</p>
    <div class="highlight highlight-js"><pre>gram my_grammar = {
    init: 'F r r F r r F',
    rules: {
        'F' -> 'F l F r r F l F',
        'r' -> turn(60),
        'l' -> turn(-60),
        'F' -> move(1)
    }
}

main() {
    grow(my_function(my_grammar), 2);
}</pre></div>
    <p>In this example, the program will construct a grammar given in the declaration of my_grammar. Then, it will output a GIF showing the growth of the fractal generated by that grammar (the fractal will have undergone 2 iterations, as specified by the second parameter to the <code>grow()</code> function).</p>


    <h3>4.2 Expressions</h3>
    <h4>4.2.1 Variable Declarations</h4>
    <p>Variables can be declared and assigned to a value simultaneously, or declared without assignment and assigned to a value later on. Declarations take the form:</p>
    <div class="highlight highlight-js"><pre>// declaration without assignment
var_type var_name;
var_name = value;

// declaration with assignment
var_type var_name = value;</pre></div>
    <p>where <code>var_type</code> is any of the four literal type keywords (<code>int</code>, <code>double</code>, <code>bool</code>, <code>string</code>), <code>var_name</code> is any valid identifier as defined in 3.1, and <code>value</code> is either a literal of type <code>var_type</code> or an expression that evaluates to a literal of that type.</p>

    <h4>4.2.2 Function Definitions</h4>
    <p>Functions are declared and defined simultaneously - unlike variables, they cannot be declared without definition and defined later. All functions must return a value, although the return type is not be specified in the function declaration. Any function except for the <code>main()</code> function is defined as follows:</p>
    <div class="highlight highlight-js"><pre>func my_name(params) {
    // function body
}</pre></div>
    <p>while the <code>main()</code> function is defined without the keyword <code>func</code>:</p>
    <div class="highlight highlight-js"><pre>main() {
    // main function body
}</pre></div>
    <p>The <code>main()</code> function should not contain any return statements.</p>

    <h4>4.2.3 Function Calls</h4>
    <p>All functions except for the <code>main()</code> function must be called explicitly, with the correct number of arguments as specified in the function definition. The <code>main()</code> function is called implicitly at the start of every program run, and calling <code>main()</code> explicitly in the program will throw an error.</p>
    <div class="highlight highlight-js"><pre>// valid function call
my_func(args);

// this will throw an error
main();</pre></div>
    <p>Function calls may be placed on the right-hand side of an assignment expression, in which case the identifier on the left-hand side will be assigned the return value of the function call.</p>
    <div class="highlight highlight-js"><pre>// n is assigned the return value of my_func(args)
int n = my_func(args);</pre></div>
    <p>Function calls may also be nested. They can be passed as arguments into other functions, in which case the return value of the inner function call will be passed as an argument to the outer function call. The return value of the inner function call must match the argument type specified in the outer function’s definition. A type mismatch will throw an error.</p>
    <div class="highlight highlight-js"><pre>/* my_func must return an object of type gram, otherwise this
   expression will throw an error */
draw(my_func(args), 2);</pre></div>

    <h4>4.2.4 Grammar Definitions</h4>
    <p>Grammar definitions are similar to function definitions, but the grammars themselves are more similar to objects.  Grammars are defined as follows:</p>
    <div class="highlight highlight-js"><pre>gram my_gram {
    init: // init string here,
    rules: {
      // start string -> end string
    }
}</pre></div>
    <p>Every grammar must contain at least one recursive (string-to-string) rule - it wouldn’t generate a fractal otherwise! Every character in the init string must have at least one and at most two corresponding rules. If a character has only one rule, that rule must be non-recursive and evaluate to a terminal. If a character has two rules, one rule must be recursive and the other must be non-recursive.  Any other combination of rules is ambiguous and will throw an error.</p>
    <p>Grammars are evaluated when they are passed into a drawing system function (<code>draw()</code> or <code>grow()</code>). Grammar evaluations start with the <code>init</code> string, which is then evaluated recursively for the number of times specified in the second argument to the drawing function call. For every recursive evaluation, the compiler will look for a recursive rule for each character, and will only use a non-recursive rule for a character if there is no recursive rule for that character. When the recursive evaluations have been completed, the compiler uses non-recursive rules to generate a final string of terminals, which are used to draw the fractal.</p>

    <h4>4.2.5 Arithmetic Expressions</h4>
    <p>Arithmetic expressions are expressions that contain an arithmetic operator, and evaluate to a literal value. They can be placed on the right-hand side of variable assignments, or passed as arguments to function calls.</p>
    <div class="highlight highlight-js"><pre>int x = 3;
int y = 8;
int z = x + y; // z = 11
my_func(x + y); // 11 is passed into my_func</pre></div>

    <h4>4.2.6 Boolean Expressions</h4>
    <p>Boolean expressions are expressions that contain logical operators, and evaluate to a boolean value <code>true</code> or <code>false</code>.  They are used to evaluate conditional and loop statements.</p>
    <div class="highlight highlight-js"><pre>bool isTrue = true;
bool isFalse = false;
if(isTrue || isFalse) {
    print(“truth”);
}</pre></div>


    <h3>4.3 Statements</h3>
    <p>A statement is a complete instruction that can be interpreted by the computer. Statements are executed sequentially within a function.</p>
    <h4>4.3.1 Expression Statements</h4>
    <p>Expression statements are the most common type of statement, and can include any of the previously covered expressions. In FRAC, all statements are terminated with a semicolon <code>;</code>.</p>
    <h4>4.3.2 Conditional Statements</h4>
    <p>Conditional statements first check the truth condition of a boolean expression, and then execute a set of statements depending on the result. Here is an example <code>if</code> / <code>else</code> conditional statement:</p>
    <div class="highlight highlight-js"><pre>if (expression) {
    statement
}
else if (expression) {
    statement
}
else {
    statement
}</pre></div>
    <p>Only the <code>if</code> clause of the conditional statement is required. The <code>else</code> statement is executed only if none of the previous conditions return true.</p>
    <h4>4.3.3 Loop Statements</h4>
    <p>Loop statements are constructed using the <code>while</code> keyword, which allows you to iterate over blocks of code.</p>
    <div class="highlight highlight-js"><pre>while (expression) {
    statement
    ...
}</pre></div>
    <p>In the case of <code>while</code> loops, the truth condition of the boolean expression is checked before every execution of the body of the <code>while</code> loop, which is executed only if expression returns true.</p>
    <h4>4.3.4 Return Statements</h4>
    <p>Ends the execution of a function with the use of the keyword <code>return</code>. If a function does not have a <code>return</code> statement at the end, it is assumed to be a void function without a return type.</p>


  <h2>5. System Functions</h2>
    <h4>1. <code>move()</code></h4>
    <p>This is one of two possible terminals in a FRAC grammar:</p>
    <div class="highlight highlight-js"><pre>move(int distance)</pre></div>
    <p>The function draws a line of length <code>distance</code>.</p>
    <h4>2. <code>turn()</code></h4>
    <p>The other possible terminal in a FRAC grammar:</p>
    <div class="highlight highlight-js"><pre>turn(int angle)</pre></div>
    <p>The function indicates to the grammar that the current line being drawn should be re-oriented by <code>angle</code> degrees, which can be in the positive or negative direction (abiding by the right hand rule).</p>
    <h4>3. <code>draw()</code></h4>
    <p>This is one of two functions in a FRAC program that generates a fractal image:</p>
    <div class="highlight highlight-js"><pre>draw(gram g, int n)</pre></div>
    <p>The function creates a static image of the fractal described by the grammar <code>g</code> over <code>n</code> number of iterations.</p>
    <h4>4. <code>grow()</code></h4>
    <div class="highlight highlight-js"><pre>grow(gram g, int n)</pre></div>
    <p>The function resembles <code>draw()</code>, except instead of creating a static image, it creates a dynamically “growing” GIF (merely a collection of static images) of the fractal described by the given grammar <code>g</code> over <code>n</code> iterations.</p>
    <h4>5. <code>print()</code></h4>
    <div class="highlight highlight-js"><pre>print(string s)</pre></div>
    <p>The function prints out the string <code>s</code> to the standard output. The same escape sequences as Java would be interpreted correspondingly (i.e. <code>\n</code> for newline).</p>

</article>
</body>
</html>
