<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui">
  <title>FRAC - Final Report</title>
  <link rel="stylesheet" href="markdown.css">
  <style>body{min-width:200px;max-width:790px;margin:0 auto;padding:30px;}</style>
</head>

<body>
<article class="markdown-body">
  <h1>FRAC: Recursive Art Compiler</h1>
    <ul>
      <li><strong>Anne Zhang </strong><code>az2350</code></li>
      <li><strong>Kunal Kamath </strong><code>kak2211</code></li>   
      <li><strong>Calvin Li </strong><code>ctl2124</code></li>
      <li><strong>Justin Chiang </strong><code>jc4127</code></li>

    </ul>

  <h2>1. Introduction</h2>
    <p>FRAC is a domain-specific programming language that enables the programmer to generate fractals in the form of bitmap image files (BMPs). The language is meant for those interested in the mathematical manipulation of recursively generated images like fractals. We designed this language to be simple, intuitive, and a joy to use!</p>
    <p>Our language uses the L-system method, which uses grammars (similar to those we learned in COMS W3261) to generate fractals. A basic FRAC program is composed of function and grammar declarations. The true power of FRAC is its ability to use simple L-system grammars to generate both static and dynamic fractal images. As you will see in examples of our compiled C code, the code for generating a fractal in C is incredibly verbose and repetitive. Grammar declarations in FRAC allow the programmer to easily play around with different rules and commands to see what fun new fractals they can generate.</p>

  <h2>2. Language Tutorial</h2>
    <h3>2.1 Compiling and Running</h3>
    <p>Run <code>make</code> in the top level directory of our source code to compile the <code>frac</code> compiler.  Then, simply run the shell script <code>run.sh</code> with a filename argument to compile and run your FRAC code. The filename must have extension .frac.</p>
    <div class="highlight highlight-js"><pre>$ ./run.sh test.frac</pre></div>
    <p>If your FRAC program generates an image, it requires the turtle graphics C library (the <code>turtle.h</code> and <code>turtle.c</code> files). Additionally, if you are using the <code>grow()</code> function to generate an animated GIF, it requires the <code>GraphicsMagick</code> and <code>gifsicle</code> libraries. All of these files are included in our source code directory, and our shell script compiles and links them as necessary.</p>

    <h3>2.3 Writing a FRAC Program</h3>
    <p>At a high level, FRAC programs are composed of function and grammar declarations. A main function is required in every program. Grammars must be declared and defined outside of functions, thus giving every grammar a global scope. The main function is the entry point of the program.</p>
    <p>The two system functions <code>draw(gram g, int n)</code> and <code>grow(gram g, int n)</code> are called on defined grammars to generate images. Grammars can be defined without being used in a system function call, but if you do that your grammar will be lost in the ether, which we do not recommend. <code>draw()</code> and <code>grow()</code> can be called multiple times, but they must only be called in the main function.  A call to the <code>draw(gram g, int n)</code> system function will generate a BMP image from the specified grammar g. The integer n specifies how many times the recursive rules defined in g are evaluated, which affects the size and complexity of the generated fractal. A call to the <code>grow(gram g, int n)</code> function will generate a series of BMPs that will be linked into a GIF, showing the growth of the fractal generated by grammar g. Each frame of the GIF is an image from iteration i of the fractal generation, where i <= n.</p>
    <p>Below are several example programs, from basic to somewhat complex, which will help give you a sense of how FRAC works.</p>

    <h3>2.2 Example Programs</h3>
      <h4>2.2.1 Hello World</h4>
      <p>This simple program prints "hello world":</p>
      <div class="highlight highlight-js"><pre>main() {
      print("hello world");
}</pre></div>
      <h4>2.2.2 GCD</h4>
      <p>This program calculates and prints the greatest common divisor (GCD) of 8 and 12:</p>
      <div class="highlight highlight-js"><pre>gcd(int x, int y) {
    while(x != y) {
        if(x > y) {
          a = a-b;
        }
        else {
            b = b-a;
        }
    }
    return a;
}

main() {
    int n = gcd(8, 12);
    print(n);
}</pre></div>
      <h4>2.2.3 Koch Snowflake</h4>
      <p>As our language is designed to facilitate generation of fractals, the best way to program in FRAC is to define grammars and draw them! For example, you can create a Koch snowflake using the following FRAC program:</p>
      <div class="highlight highlight-js"><pre>gram koch = {
    alphabet: [F, p, m],
    init: 'F p p F p p F',
    rules: {
        'F' -> 'F m F p p F m F',
        'F' -> move(1),
        'm' -> rturn(60),
        'p' -> lturn(60)
    }
}

main() {
    draw(koch, 6);
}</pre></div>
      <img src="koch.bmp" style="width:256px;height:280px;">
      <h4>2.2.4 Sierpinski Triangle</h4>
      <p>Another fun fractal is the Sierpinski triangle. The grammar for generating a Sierpinski triangle is somewhat more complex than the Koch snowflake (but still easy to write):</p>
      <div class="highlight highlight-js"><pre>gram sierp = {
    alphabet: [A, B, p, m],
    init: 'A',
    rules: {
        'A' -> 'p B m A m B p',
        'A' -> move(1),
        'B' -> 'm A p B p A m',
        'B' -> move(1),
        'p' -> lturn(60),
        'm' -> rturn(60)
    }
}

main() {
    draw(sierp, 9);
}</pre></div>
      <img src="sierp.bmp" style="width:290px;height:256px;">

      <br>
      <h2>GROW EXAMPLE HERE</h2>
      <br>

  <h2>3. Language Reference Manual</h2>
    <h3>3.1. Data Types & Data Structures</h3>
      <p>The language supports two categories of data types: primitive types and complex types.</p>
      <h4>3.1.1 Primitive types</h4>
      <p>A primitive type requires a small and fixed amount of memory to store a single logical value. Typical primitive types include <code>int</code>, <code>double</code>, and <code>bool</code>. One exception is <code>string</code>, which requires a variable amount of memory storage.</p>
      <p>Explicit and implicit type conversion between <code>int</code> and <code>double</code> is allowed, but no other type conversions are supported, with the exception of “reflexive conversions” (e.g. converting <code>double</code> to <code>double</code>). Explicit type conversion can be performed with the following syntax:</p>
      <div class="highlight highlight-js"><pre>double x = 3.5;
x = (double) x;  // reflexive conversions are permitted
int y = (int) x;
double z = (double) y;</pre></div>
      <p>Alternatively, omitting the explicit parentheses-enclosed target type produces an identical outcome.</p>
      <div class="highlight highlight-js"><pre>double x = 3.5;
x = x;
int y = x;
double z = y;</pre></div>
      <p>Note that explicit type conversion can operate on both variables and constants. Therefore, the following is permitted:</p>
      <div class="highlight highlight-js"><pre>int a = (int) 3.5;</pre></div>
      <p>Converting a double to an integer results in truncation of the fractional part, while converting an integer to a double results in the addition of a fractional part with a value of zero.</p>
      <p>When performing an arithmetic operation between an integer and a double, the compiler automatically promotes the integer into a double. Thus, the following three statements are operationally equivalent:</p>
      <div class="highlight highlight-js"><pre>double c = 3.5 + 3;  // c is 6.5

double c = 3.5 + (double) 3;  // c is 6.5
double c = 3.5 + 3.0;  // c is 6.5</pre></div>
      <h4>3.1.2 Complex types</h4>
      <p>A complex type contains multiple named fields and requires a larger and variable amount of memory to store a structured collection of values. A complex type is similar to the familiar object type in so far as it contains fields, but a complex type does not contain any methods. In fact, all instantiated complex types are immutable; operating on them requires the use of functions.</p>
      <p>Two complex types are supported in the language: <code>gram</code> and <code>rule</code>.</p>
      <p>A <code>gram</code> represents a formal grammar that is used to specify a fractal that can be drawn. A <code>rule</code> represents a production rule that is a part of the formal grammar. Later sections expand on how such grammars and rules can be declared in code.</p>
      <p>Just like in Java, // for single line and /* */ for multi line comments.</p>

  <h3>3.2. Lexical Conventions</h3>
    <h4>3.2.1 Identifiers</h4>
    <p>An identifier is a sequence of alphanumerics and underscores. An identifier may begin with neither a digit nor an underscore. Both uppercase and lowercase letters are permitted. The following are valid identifiers: <code>kunal_43</code>, <code>hello_ANNIE</code>, and <code>do_this____justin</code>. The following are invalid: <code>helloworld&</code>, <code>_dothis</code>, and <code>4calvin</code>.</p>
    <h4>3.2.2 Keywords</h4>
    <p>The following are a list of reserved keywords in the language:</p>
    <div class="highlight highlight-js"><pre>rule
gram
func
if
else
while
return
true
false</pre></div>
    <p>as well as the literal types:</p>
    <div class="highlight highlight-js"><pre>int
double
bool
string</pre></div>
    <p>No keyword may be used as an identifier.</p>
    <h4>3.2.3 Literals</h4>
    <p>A literal is a notation that represents the value itself as written. Literals can only be of one of the primitive types, which are discussed below. A literal may not be used as an identifier.</p>
    <h5>Integer constants</h5>
    <p>An integer consists of a sequence of digits not containing a decimal point.</p>
    <div class="highlight highlight-js"><pre>int x = 10;</pre></div>
    <h5>Floating point constants</h5>
    <p>A floating point constant consists of two sequences of digits, where one may be the empty sequence, separated by a decimal point.</p>
    <div class="highlight highlight-js"><pre>double y = 4.55;</pre></div>
    <h5>Boolean constants</h5>
    <p>There exist only two boolean constants:</p>
    <div class="highlight highlight-js"><pre>bool is_there = true;
bool is_there = false;</pre></div>
    <h5>String constants</h5>
    <p>A string constant consists of a sequence of characters enclosed by single quotes.</p>
    <div class="highlight highlight-js"><pre>string name = 'Anne Zhang’;</pre></div>


    <h4>3.2.4 Comments</h4>
    <p>Just like in Java, <code>//</code> are used for single line comments and <code>/* */</code> for nested or multi-line comments.</p>
    <div class="highlight highlight-js"><pre>// This is a single line comment
/* This is
   a multi-line
   comment
 */</pre></div>
    <p>In a single line, all characters after <code>//</code> are ignored by the compiler.</p>
    <p>With multi-line comments, the compiler will ignore everything from <code>/*</code> to <code>*/</code>. Note, however, that multi-line comments cannot be nested within one another like so:</p>
    <div class="highlight highlight-js"><pre>/* Multi-line comments
   /* cannot be nested */
   like in this example!
 */</pre></div>
    <p>This will result in a syntax error, as the compiler will treat the first <code>*/</code> as the end of the comment.</p>
    <h4>3.2.5 Operators</h4>
    <p>Operators specify logical or mathematical operations to be performed.</p>
    <p>Arithmetic operators:<br>
<code>+</code> 	addition<br>
<code>-</code>	subtraction<br>
<code>*</code>	multiplication<br>
<code>/</code>	division<br>
<code>%</code>	modulo</p>
    <p><code>=</code> assignment</p>
    <p>Logical operators:<br>
<code>!</code>	negation<br>
<code>==</code>	equivalence<br>
<code>!=</code>	non-equivalence<br>
<code><</code>	less than<br>
<code>></code>	greater than<br>
<code>&&</code>	AND<br>
<code>||</code>	OR</p>
    <p>The arrow <code>-></code> is a special operator used in rule definitions in grammars.  In a rule, the string to the left of the arrow can be replaced by the string or system function to the right of the arrow.  For example:</p>
    <div class="highlight highlight-js"><pre>'F' -> 'F l F r r F l F',
'r' -> turn(60)</pre></div>
    <p>are both valid rules.  The arrow has no meaning outside of rule definitions, and an error will be thrown if it is used outside of this context.</p>
    <h4>3.2.6 Punctuators</h4>
    <p><code>;</code>
      <ul><li>terminate statements</li></ul></p>
    <p><code>,</code>
      <ul><li>separate function parameters, separate key-value pairs in grammar definitions</li></ul>
    <p><code>'</code>
      <ul><li>string literal declaration</li></ul>
    <p><code>{}</code>
      <ul><li>grammar definitions</li>
      <li>scope</li></ul>
    <p><code>()</code>
      <ul><li>function arguments</li>
      <li>expression precedence</li>
      <li>type casting</li>
      <li>conditional parameters</li></ul>


  <h3>3.4. Syntax</h3>
    <h4>3.4.1 Program Structure</h4>
    <p>FRAC programs should be written in a single file.  A FRAC program consists of grammar definitions, function definitions, and a <code>main()</code> function.  Functions and grammars are defined first and subsequently used in the <code>main()</code> function, although they cannot be defined within the <code>main()</code> function itself.</p>
    <p>The <code>main()</code> function is the entry point for the program.  It may contain variable and literal declarations, expressions, and statements.  It may also use any previously defined functions and grammars.  In addition, the <code>main()</code> function must use one, and only one, of the following system functions: <code>draw()</code>, <code>grow()</code>.  This function specifies the type of image output that the program will create.</p>
    <p>The following is an example of a valid FRAC program:</p>
    <div class="highlight highlight-js"><pre>gram my_grammar = {
    init: 'F r r F r r F',
    rules: {
        'F' -> 'F l F r r F l F',
        'r' -> turn(60),
        'l' -> turn(-60),
        'F' -> move(1)
    }
}

main() {
    grow(my_function(my_grammar), 2);
}</pre></div>
    <p>In this example, the program will construct a grammar given in the declaration of my_grammar. Then, it will output a GIF showing the growth of the fractal generated by that grammar (the fractal will have undergone 2 iterations, as specified by the second parameter to the <code>grow()</code> function).</p>


    <h4>3.4.2 Expressions</h4>
    <h5>Variable Declarations</h5>
    <p>Variables can be declared and assigned to a value simultaneously, or declared without assignment and assigned to a value later on. Declarations take the form:</p>
    <div class="highlight highlight-js"><pre>// declaration without assignment
var_type var_name;
var_name = value;

// declaration with assignment
var_type var_name = value;</pre></div>
    <p>where <code>var_type</code> is any of the four literal type keywords (<code>int</code>, <code>double</code>, <code>bool</code>, <code>string</code>), <code>var_name</code> is any valid identifier as defined in 3.1, and <code>value</code> is either a literal of type <code>var_type</code> or an expression that evaluates to a literal of that type.</p>

    <h5>Function Definitions</h5>
    <p>Functions are declared and defined simultaneously - unlike variables, they cannot be declared without definition and defined later. All functions must return a value, although the return type is not be specified in the function declaration. Any function except for the <code>main()</code> function is defined as follows:</p>
    <div class="highlight highlight-js"><pre>func my_name(params) {
    // function body
}</pre></div>
    <p>while the <code>main()</code> function is defined without the keyword <code>func</code>:</p>
    <div class="highlight highlight-js"><pre>main() {
    // main function body
}</pre></div>
    <p>The <code>main()</code> function should not contain any return statements.</p>

    <h5>Function Calls</h5>
    <p>All functions except for the <code>main()</code> function must be called explicitly, with the correct number of arguments as specified in the function definition. The <code>main()</code> function is called implicitly at the start of every program run, and calling <code>main()</code> explicitly in the program will throw an error.</p>
    <div class="highlight highlight-js"><pre>// valid function call
my_func(args);

// this will throw an error
main();</pre></div>
    <p>Function calls may be placed on the right-hand side of an assignment expression, in which case the identifier on the left-hand side will be assigned the return value of the function call.</p>
    <div class="highlight highlight-js"><pre>// n is assigned the return value of my_func(args)
int n = my_func(args);</pre></div>
    <p>Function calls may also be nested. They can be passed as arguments into other functions, in which case the return value of the inner function call will be passed as an argument to the outer function call. The return value of the inner function call must match the argument type specified in the outer function’s definition. A type mismatch will throw an error.</p>
    <div class="highlight highlight-js"><pre>/* my_func must return an object of type gram, otherwise this
   expression will throw an error */
draw(my_func(args), 2);</pre></div>

    <h5>Grammar Definitions</h5>
    <p>Grammar definitions are similar to function definitions, but the grammars themselves are more similar to objects.  Grammars are defined as follows:</p>
    <div class="highlight highlight-js"><pre>gram my_gram {
    init: // init string here,
    rules: {
      // start string -> end string
    }
}</pre></div>
    <p>Every grammar must contain at least one recursive (string-to-string) rule - it wouldn’t generate a fractal otherwise! Every character in the init string must have at least one and at most two corresponding rules. If a character has only one rule, that rule must be non-recursive and evaluate to a terminal. If a character has two rules, one rule must be recursive and the other must be non-recursive.  Any other combination of rules is ambiguous and will throw an error.</p>
    <p>Grammars are evaluated when they are passed into a drawing system function (<code>draw()</code> or <code>grow()</code>). Grammar evaluations start with the <code>init</code> string, which is then evaluated recursively for the number of times specified in the second argument to the drawing function call. For every recursive evaluation, the compiler will look for a recursive rule for each character, and will only use a non-recursive rule for a character if there is no recursive rule for that character. When the recursive evaluations have been completed, the compiler uses non-recursive rules to generate a final string of terminals, which are used to draw the fractal.</p>

    <h5>Arithmetic Expressions</h5>
    <p>Arithmetic expressions are expressions that contain an arithmetic operator, and evaluate to a literal value. They can be placed on the right-hand side of variable assignments, or passed as arguments to function calls.</p>
    <div class="highlight highlight-js"><pre>int x = 3;
int y = 8;
int z = x + y; // z = 11
my_func(x + y); // 11 is passed into my_func</pre></div>

    <h5>Boolean Expressions</h5>
    <p>Boolean expressions are expressions that contain logical operators, and evaluate to a boolean value <code>true</code> or <code>false</code>.  They are used to evaluate conditional and loop statements.</p>
    <div class="highlight highlight-js"><pre>bool isTrue = true;
bool isFalse = false;
if(isTrue || isFalse) {
    print(“truth”);
}</pre></div>


    <h4>3.4.3 Statements</h4>
    <p>A statement is a complete instruction that can be interpreted by the computer. Statements are executed sequentially within a function.</p>
    <h5>Expression Statements</h5>
    <p>Expression statements are the most common type of statement, and can include any of the previously covered expressions. In FRAC, all statements are terminated with a semicolon <code>;</code>.</p>
    <h5>Conditional Statements</h5>
    <p>Conditional statements first check the truth condition of a boolean expression, and then execute a set of statements depending on the result. Here is an example <code>if</code> / <code>else</code> conditional statement:</p>
    <div class="highlight highlight-js"><pre>if (expression) {
    statement
}
else if (expression) {
    statement
}
else {
    statement
}</pre></div>
    <p>Only the <code>if</code> clause of the conditional statement is required. The <code>else</code> statement is executed only if none of the previous conditions return true.</p>
    <h5>Loop Statements</h5>
    <p>Loop statements are constructed using the <code>while</code> keyword, which allows you to iterate over blocks of code.</p>
    <div class="highlight highlight-js"><pre>while (expression) {
    statement
    ...
}</pre></div>
    <p>In the case of <code>while</code> loops, the truth condition of the boolean expression is checked before every execution of the body of the <code>while</code> loop, which is executed only if expression returns true.</p>
    <h5>Return Statements</h5>
    <p>Ends the execution of a function with the use of the keyword <code>return</code>. If a function does not have a <code>return</code> statement at the end, it is assumed to be a void function without a return type.</p>

  <h3>3.5. System Functions</h3>
    <h5>1. <code>move()</code></h5>
    <p>This is one of two possible terminals in a FRAC grammar:</p>
    <div class="highlight highlight-js"><pre>move(int distance)</pre></div>
    <p>The function draws a line of length <code>distance</code>.</p>
    <h5>2. <code>turn()</code></h5>
    <p>The other possible terminal in a FRAC grammar:</p>
    <div class="highlight highlight-js"><pre>turn(int angle)</pre></div>
    <p>The function indicates to the grammar that the current line being drawn should be re-oriented by <code>angle</code> degrees, which can be in the positive or negative direction (abiding by the right hand rule).</p>
    <h5>3. <code>draw()</code></h5>
    <p>This is one of two functions in a FRAC program that generates a fractal image:</p>
    <div class="highlight highlight-js"><pre>draw(gram g, int n)</pre></div>
    <p>The function creates a static BMP image of the fractal described by the grammar <code>g</code> over <code>n</code> number of iterations.</p>
    <h5>4. <code>grow()</code></h5>
    <div class="highlight highlight-js"><pre>grow(gram g, int n)</pre></div>
    <p>The function resembles <code>draw()</code>, except instead of creating a static image, it creates a dynamically “growing” GIF (by linking together a collection of static BMP images) of the fractal described by the given grammar <code>g</code> over <code>n</code> iterations.</p>
    <h5>5. <code>print()</code></h5>
    <div class="highlight highlight-js"><pre>print(string s)</pre></div>
    <p>The function prints out the string <code>s</code> to the standard output. The same escape sequences as Java would be interpreted correspondingly (i.e. <code>\n</code> for newline).</p>

  <h2>4. Project Plan</h2>
  <h3>4.1 Process & Timeline</h3>
  <p>We decided that we wanted to create a fractal-generating language in late September. We began to design the language in early October, and continued to flesh out ideas until the beginning of November. Programming of the compiler began in earnest in November. We completed a basic front-end and basic code generator in mid-November. We worked on building the semantic checker and code generator, as well as expanding the front-end, well into December. Finally, we linked all the parts together, obtaining our first successful fractal images in mid-December.</p>
  <p>While building our language and the compiler, members of our group tried to work together as much as possible. Pair programming was a crucial part of our strategy - we recognized that this allowed us to catch errors much more easily, as well as write clearer and more readable code.</p>

  <h3>4.2 Team Roles</h3>

  <h3>4.3 Development Tools</h3>

  <h2>5. Architectural Design</h2>
  <img src="architecture.png" style="width:600px;height:350px">

  <h3>5.1. Compiler Structure</h3>
  <p>The scanner <code>scanner.mll</code> parses a FRAC program into a list of recognizable tokens. The parser <code>parser.mly</code> makes sure that there are no syntax errors, and uses this list of tokens to generate an abstract syntax tree (AST). Then, the semantic checker <code>semantic.ml</code> walks through the AST, making sure that there are no semantic errors, and generates an SAST. Finally, the code generator <code>compile.ml</code> walks through the SAST and generates the C target code.</p>

  <h3>5.2. Turtle Graphics in C</h3>
  <p>Our compiled C code uses a turtle graphics library to generate fractal images. The library that we use, which can be found in our source code, uses simple commands like <code>turtle_forward()</code>, <code>turtle_turn_right()</code>, and<code>turtle_turn_left()</code> to generate graphics. The terminal functions used in FRAC grammar declarations map directly to these functions.</p>
  <p>When compiled into C, each grammar declaration in a FRAC program is transformed into two functions. The first function, <code>[gram_name]()</code>, represents the rules of the grammar. The second function, <code>[gram_name]_start()</code>, represents the init string of the grammar. Each rule symbol becomes a call to the <code>[gram_name]()</code> function.</p>
  <p>If any <code>draw()</code> or <code>grow()</code> functions are called in the main function, the compiler generates the C code necessary for creating, saving, and cleaning up and image. The following is an example of the C program generated from the Koch snowflake FRAC program included in Section 2.2.3.</p>
        <div class="highlight highlight-js"><pre>#include "turtle.h"
#include <string.h>
#include <stdio.h>

void koch(char var, int iter) {
    if (iter < 0) {
        if (var == 'F') {
            turtle_forward(1);
        }
    } else {
        if(var == 'F') {
            koch('F', iter - 1);
            koch('m', iter - 1);
            koch('F', iter - 1);
            koch('p', iter - 1);
            koch('p', iter - 1);
            koch('F', iter - 1);
            koch('m', iter - 1);
            koch('F', iter - 1);
        }
        if (var == 'm') {
            turtle_turn_right(60);
        }
        if (var == 'p') {
            turtle_turn_left(60);
        }
    }
}

void koch_start(int iter) {
    koch('F', iter);
    koch('p', iter);
    koch('p', iter);
    koch('F', iter);
    koch('p', iter);
    koch('p', iter);
    koch('F', iter);
}

int main(){
    turtle_init(2000, 2000);
    koch_start(6);
    turtle_save_bmp("koch.bmp");
    turtle_cleanup();
    return 0;
}</pre></div>

  <h3>5.3. GIF Generation</h3>

  <h2>6. Testing Plan</h2>

  <h2>7. Lessons Learned</h2>

  <h2>8. Appendix</h2>
  <h3>8.1 Scanner</h3>
  <code>scanner.mll</code><br><br>
  
  <div class="highlight highlight-js"><pre>{ open Parser }

let num = ('-')?['0'-'9']+
let dbl = ('-')?(['0'-'9']+'.'['0'-'9']+ | '.'['0'-'9']+)
let boolean = "true" | "false"

rule token = parse
(* Whitespace *)
  [' ' '\t' '\r' '\n'] { token lexbuf }
(* Comments *)
| "/*"     { multi_comment lexbuf }
| "//"     { single_comment lexbuf }
(* Punctuation *)
| '('      { LPAREN } | ')'      { RPAREN }
| '{'      { LBRACE } | '}'      { RBRACE }
| ';'      { SEMI }   | ','      { COMMA }
(* Arithmetic Operators *)
| '+'      { PLUS }   | '-'      { MINUS }
| '*'      { TIMES }  | '/'      { DIVIDE }
| '%'      { MOD }    | '='      { ASSIGN }
(* Logical Operators *)
| "=="     { EQ }     | "!="     { NEQ }
| '<'      { LT }     | "<="     { LEQ }
| ">"      { GT }     | ">="     { GEQ }
| "||"     { OR }     | "&&"     { AND }
| '!'      { NOT }

(* Grammar Syntax *)
| "gram"   { GRAM }    | "rules"    { RULES }
| "init"   { INIT }    | "alphabet" { ALPHABET }
| ':'      { COLON }   | '''        { QUOTE }
| '['      { LSQUARE } | ']'        { RSQUARE }
| "->"     { ARROW }
| "rturn"  { RTURN }  | "lturn"    { LTURN }
| "move"     { MOVE }

(* Statements *)
| "if"     { IF }
| "else"   { ELSE }
| "for"    { FOR }
| "while"  { WHILE }
| "return" { RETURN }

(* Type Names *)
| "int"    { INT }
| "double" { DOUBLE }
| "string" { STRING }
| "bool"   { BOOL }
| '"'      { read_string (Buffer.create 17) lexbuf }
| num as lxm { INT_LIT (int_of_string lxm) }
| dbl as lxm { DOUBLE_LIT (float_of_string lxm) }
| boolean as lxm  { BOOL_LIT (bool_of_string lxm) }
| ['a'-'z' 'A'-'Z']['a'-'z' 'A'-'Z' '0'-'9' '_']* as lxm { ID (lxm) }
| eof { EOF }
| _ as char { raise (Failure("illegal character " ^ Char.escaped char)) }

and read_string buf =
  parse
  | '"'       { STRING_LIT (Buffer.contents buf) } (*
  | '\\' '/'  { Buffer.add_char buf '/'; read_string buf lexbuf }
  | '\\' '\\' { Buffer.add_char buf '\\'; read_string buf lexbuf }
  | '\\' 'b'  { Buffer.add_char buf '\b'; read_string buf lexbuf }
  | '\\' 'f'  { Buffer.add_char buf '\012'; read_string buf lexbuf }
  | '\\' 'n'  { Buffer.add_char buf '\n'; read_string buf lexbuf }
  | '\\' 'r'  { Buffer.add_char buf '\r'; read_string buf lexbuf }
  | '\\' 't'  { Buffer.add_char buf '\t'; read_string buf lexbuf }
  | [^ '"' '\\']+
    { Buffer.add_string buf (Lexing.lexeme lexbuf);
      read_string buf lexbuf
    }
  | _ { raise (Failure ("Illegal string character: " ^ Lexing.lexeme lexbuf)) } *)
  | _ { Buffer.add_string buf (Lexing.lexeme lexbuf); read_string buf lexbuf}
  | eof { raise (Failure ("String is not terminated")) }

and multi_comment = parse
  "*/" { token lexbuf }
| _    { multi_comment lexbuf }

and single_comment = parse
  '\n' { token lexbuf }
| _    { single_comment lexbuf }</pre></div>

  <h3>8.2 Parser</h3>
  <code>parser.mly</code><br><br>

  <div class="highlight highlight-js"><pre>%{ open Ast %}

%token SEMI COMMA COLON
%token LPAREN RPAREN LBRACE RBRACE
%token PLUS MINUS TIMES DIVIDE MOD ASSIGN
%token EQ NEQ LT LEQ GT GEQ
%token OR AND NOT
%token RETURN IF ELSE FOR WHILE
%token INT DOUBLE STRING BOOL
%token GRAM ALPHABET INIT RULES
%token LSQUARE RSQUARE ARROW QUOTE HYPHEN
%token RTURN LTURN MOVE
%token <string> ID
%token <int> INT_LIT
%token <float> DOUBLE_LIT
%token <string> STRING_LIT
%token <bool> BOOL_LIT
%token EOF

%nonassoc NOELSE
%nonassoc ELSE
%right ASSIGN
%left OR AND
%left EQ NEQ
%left LT GT LEQ GEQ
%left PLUS MINUS
%left TIMES DIVIDE MOD
%right NOT

%start program
%type <Ast.program> program

%%

program:
    /* nothing */      { [], [] }
  | program gdecl      { let (grams, funcs) = $1 in $2::grams, funcs }
  | program fdecl      { let (grams, funcs) = $1 in grams, $2::funcs }

/* VARIABLES */

var_type:
    INT    { Int }
  | DOUBLE { Double }
  | STRING { String }
  | BOOL   { Bool }
  | GRAM   { Gram }

vdecl:
    var_type ID SEMI              { Var($1, $2)}
  | var_type ID                   { Var($1, $2)}
  | var_type ID ASSIGN expr SEMI  { Var_Init($1, $2, $4)}

vdecl_list:
    /* nothing */    { [] }
  | vdecl_list vdecl { $2 :: $1 }

/* RULES */

rule_id_list:
    ID                     { [$1] }
  | rule_id_list ID  { $2 :: $1 }

comma_list:
    ID                     { [$1] }
  | comma_list COMMA ID  { $3 :: $1 }

rule:
    QUOTE ID QUOTE ARROW RTURN LPAREN expr RPAREN   { Term($2, Rturn($7)) }
  | QUOTE ID QUOTE ARROW LTURN LPAREN expr RPAREN   { Term($2, Lturn($7)) }
  | QUOTE ID QUOTE ARROW MOVE LPAREN expr RPAREN    { Term($2, Move($7)) }
  | QUOTE ID QUOTE ARROW QUOTE rule_id_list QUOTE   { Rec($2, List.rev $6) }

rule_list:
    rule                  { [$1] }
  | rule_list COMMA rule  { $3 :: $1 }

/* GRAMS */

gdecl:
    GRAM ID ASSIGN LBRACE
      ALPHABET COLON LSQUARE comma_list RSQUARE COMMA
      INIT COLON QUOTE rule_id_list QUOTE COMMA
      RULES COLON LBRACE rule_list RBRACE
    RBRACE
    { { gname = $2;
        alphabet = $8;
        init = $14;
        rules = List.rev $20 } }

 /* FUNCTIONS */

fdecl:
   ID LPAREN formals_opt RPAREN LBRACE vdecl_list stmt_list RBRACE
     { { fname = $1;
     formals = $3;
     locals = List.rev $6;
     body = List.rev $7 } }

formals_opt:
    /* nothing */ { [] }
  | formal_list   { List.rev $1 }

formal_list:
    vdecl                  { [$1] }
  | formal_list COMMA vdecl { $3 :: $1 }

/* STATEMENTS */

stmt:
    expr SEMI                                            { Expr($1) }
  | RETURN expr SEMI                                     { Return($2) }
  | LBRACE stmt_list RBRACE                              { Block(List.rev $2) }
  | IF LPAREN expr RPAREN stmt %prec NOELSE              { If($3, $5, Block([])) }
  | IF LPAREN expr RPAREN stmt ELSE stmt                 { If($3, $5, $7) }
  | FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt      { For($3, $5, $7, $9) }
  | WHILE LPAREN expr RPAREN stmt                        { While($3, $5) }

stmt_list:
    /* nothing */  { [] }
  | stmt_list stmt { $2 :: $1 }

/* EXPRESSIONS */

expr:
    INT_LIT          { Int_lit($1) }
  | DOUBLE_LIT       { Double_lit($1) }
  | ID               { Id($1) }
  | STRING_LIT       { String_lit($1) }
  | BOOL_LIT         { Bool_lit($1) }
  | LPAREN expr RPAREN { ParenExpr($2) }
  | NOT expr         { Unop(Not, $2) }
  | expr PLUS   expr { Binop($1, Add,   $3) }
  | expr MINUS  expr { Binop($1, Sub,   $3) }
  | expr TIMES  expr { Binop($1, Mult,  $3) }
  | expr DIVIDE expr { Binop($1, Div,   $3) }
  | expr MOD    expr { Binop($1, Mod,   $3) }
  | expr EQ     expr { Binop($1, Equal, $3) }
  | expr NEQ    expr { Binop($1, Neq,   $3) }
  | expr LT     expr { Binop($1, Less,  $3) }
  | expr LEQ    expr { Binop($1, Leq,   $3) }
  | expr GT     expr { Binop($1, Greater, $3) }
  | expr OR     expr { Binop($1, Or,    $3) }
  | expr AND    expr { Binop($1, And,   $3) }
  | expr GEQ    expr { Binop($1, Geq,   $3) }
  | ID ASSIGN expr   { Assign($1, $3) }
  | ID LPAREN actuals_opt RPAREN { Call($1, $3) }

actuals_opt:
    /* nothing */ { [] }
  | actuals_list  { List.rev $1 }

actuals_list:
    expr                    { [$1] }
  | actuals_list COMMA expr { $3 :: $1 }</pre></div>

  <h3>8.3 AST</h3>
  <code>ast.ml</code><br><br>
  <div class="highlight highlight-js"><pre>(* Operators *)
type op = Add | Sub | Mult | Div | Mod | Equal | Neq | Less | Leq 
| Greater | Geq | Or | And | Not

(* Variable types *)
type var_type =
    Void
  | Int
  | Double
  | String
  | Bool
  | Gram

(* Expressions *)
type expr =
    Int_lit of int
  | Double_lit of float
  | Id of string
  | String_lit of string
  | Bool_lit of bool
  | ParenExpr of expr
  | Unop of op * expr
  | Binop of expr * op * expr
  | Assign of string * expr
  | Call of string * expr list
  | Noexpr

(* Statements *)
type stmt =
    Expr of expr
  | Block of stmt list
  | Return of expr
  | If of expr * stmt * stmt
  | For of expr * expr * expr * stmt
  | While of expr * stmt

(* Variable Declarations *)
type var_decl =
    Var of var_type * string
  | Var_Init of var_type * string * expr

type term =
    Rturn of expr
  | Lturn of expr
  | Move of expr

(* Rule Definitions *)
type rule =
    Rec of string * string list
  | Term of string * term

(* Grammar Declarations *)
type gram_decl = {
  gname : string;
  alphabet : string list;
  init : string list;
  rules : rule list;
}

(* Function Declarations *)
type func_decl = {
  fname : string;
  formals : var_decl list;
  locals : var_decl list;
  body : stmt list;
}

(* Program entry point *)
type program = gram_decl list * func_decl list</pre></div>

<h3>8.4 Semantic Checker</h3>
<code>semantic.ml</code><br><br>
<div class="highlight highlight-js"><pre>open Ast
open Sast

type symbol_table = {
  mutable vars: var_decl list;
  mutable funcs: func_decl list;
  mutable grams: gram_decl list;
}

(**************
 * Exceptions *
**************)

exception Failure of string

let op_error t = match t with
    Ast.Not -> raise (Failure("Invalid use of unop: '!'"))
  | Ast.Add -> raise (Failure("Invalid types for binop: '+'"))
  | Ast.Sub -> raise (Failure("Invalid types for binop: '-'"))
  | Ast.Mult -> raise (Failure("Invalid types for binop: '*'"))
  | Ast.Div -> raise (Failure("Invalid types for binop: '/'"))
  | Ast.Mod -> raise (Failure("Invalid types for binop: '%'"))
  | Ast.Or -> raise (Failure("Invalid types for binop: '||'"))
  | Ast.And -> raise (Failure("Invalid types for binop: '&&'"))
  | Ast.Equal -> raise (Failure("Invalid types for binop: '=='"))
  | Ast.Neq -> raise (Failure("Invalid types for binop: '!='"))
  | Ast.Less -> raise (Failure("Invalid types for binop: '<'"))
  | Ast.Greater -> raise (Failure("Invalid types for binop: '>'"))
  | Ast.Leq -> raise (Failure("Invalid types for binop: '<='"))
  | Ast.Geq -> raise (Failure("Invalid types for binop: '>='"))

(**************
 * Checking *
**************)

let rec check_expr (env : symbol_table) (expr : Ast.expr) = match expr with
    Noexpr -> Sast.Noexpr, Void
  | Id(str) -> (match (find_vname str env.vars) with
                  Var(vt, s) -> Sast.Id(s), vt
                | Var_Init(vt, s, e) -> Sast.Id(s), vt)
  | Int_lit(i) -> Sast.Int_lit(i), Sast.Int
  | Double_lit(d) -> Sast.Double_lit(d), Sast.Double
  | String_lit(s) -> Sast.String_lit(s), Sast.String
  | Bool_lit(b) -> Sast.Bool_lit(b), Sast.Boolean
  | ParenExpr(e) -> check_paren_expr env e
  | Unop(_, _) as u -> check_unop env u
  | Binop(_, _, _) as b -> check_binop env b
  | Assign(_, _) as a -> check_assign env a
  | Call(_, _) as c -> check_call env c

and check_paren_expr (env : symbol_table) pe =
  let e = check_expr env pe in
  let (_, t) = e in
  Sast.ParenExpr(e), t

and find_vname (vname : string) (vars : Sast.var_decl list) = match vars with
    [] -> raise(Failure "variable not defined")
  | hd :: tl -> let name = (match hd with
                              Var(vt, s) -> s
                            | Var_Init(vt, s, e) -> s) in
                if(vname = name) then hd
                else find_vname vname tl

and check_unop (env : symbol_table) unop = match unop with
  Ast.Unop(op, e) ->
    (match op with
      Not ->
        let expr = check_expr env e in
        let (_, t) = expr in
        if (t <> Boolean)
          then op_error op
        else Sast.Unop(op, expr), t
      | _ -> raise (Failure "Invalid unary operator"))
  | _ -> raise (Failure "Invalid unary operator")

and check_binop (env : symbol_table) binop = match binop with
  Ast.Binop(ex1, op, ex2) ->
    let e1 = check_expr env ex1 and e2 = check_expr env ex2 in
    let (_, t1) = e1 and (_, t2) = e2 in
    let t = match op with
        Mod ->
          if (t1 <> Int || t2 <> Int)
                then op_error op
          else Sast.Int
      | Add | Sub | Mult | Div ->
          if (t1 <> Int || t2 <> Int) then
            if (t1 <> Double || t2 <> Double)
              then op_error op
            else Sast.Double
          else Sast.Int
      | Greater | Less | Leq | Geq ->
          if (t1 <> Int || t2 <> Int) then
            if (t1 <> Double || t2 <> Double)
              then op_error op
            else Sast.Boolean
          else Sast.Boolean
      | And | Or ->
          if (t1 <> Boolean || t2 <> Boolean)
            then op_error op
          else Sast.Boolean
      | Equal | Neq ->
          if (t1 <> Int || t2 <> Int) then
            if (t1 <> Double || t2 <> Double) then
              if (t1 <> Boolean || t2 <> Boolean)
                then op_error op
              else Sast.Boolean
            else Sast.Boolean
          else Sast.Boolean
      | _ -> raise (Failure "Invalid binary operator")
    in Sast.Binop(e1, op, e2), t
  | _ -> raise (Failure "Not a binary operator")

and check_assign (env : symbol_table) a = match a with
  Ast.Assign(id, expr) ->
    let vdecl = find_vname id env.vars in
    let (t,n) = (match vdecl with
              Var(vt, s) -> (vt,s)
            | Var_Init(vt, s, e) -> (vt,s)) in
    let e = check_expr env expr in
    let (_, t2) = e in
    if t <> t2 then raise (Failure "Incorrect type for assignment") else Sast.Assign(n, e), t
  | _ -> raise (Failure "Not a valid assignment")

and check_call (env : symbol_table) c = match c with
    Ast.Call(f, actuals) -> (match f with
        "print" -> (match actuals with
            []        -> raise(Failure "print() requires an argument")
          | hd :: []     -> let (id, t) = check_expr env hd in (match t with
                                Sast.Void -> raise(Failure "cannot print an expression of type void")
                              | _ -> Sast.Call(f, [(id, t)]), Sast.Void)
          | hd :: tl -> raise(Failure "print() only takes one argument"))
      | "draw" -> (match actuals with
            [g; i] -> (match (g, i) with
                          (Id(s), Int_lit(n)) -> ignore(try
                                                  List.find(fun gram -> gram.gname = s) env.grams
                                                  with Not_found -> raise(Failure ("gram " ^ s ^ " not defined")));
                          Sast.Call(f, [Sast.Id(s), Sast.Gram; Sast.Int_lit(n), Sast.Int]), Sast.Void
                        | _ -> raise(Failure "draw takes a gram g and int n as arguments"))
          | _      -> raise(Failure "draw() requires two arguments"))
      | "grow" -> (match actuals with
            [g; i] -> (match (g, i) with
                          (Id(s), Int_lit(n)) -> ignore(try
                                                  List.find(fun gram -> gram.gname = s) env.grams
                                                  with Not_found -> raise(Failure ("gram " ^ s ^ " not defined")));
                          Sast.Call(f, [Sast.Id(s), Sast.Gram; Sast.Int_lit(n), Sast.Int]), Sast.Void
                        | _ -> raise(Failure "grow takes a gram g and int n as arguments"))
          | _      -> raise(Failure "draw() requires two arguments"))
      | _ -> let called_func = (try
                List.find(fun func -> func.fname = f) env.funcs
                with Not_found -> raise(Failure ("function " ^ f ^ " not defined"))) in
             Sast.Call(f, (check_args env (called_func.formals, actuals))), called_func.rtype)
  | _ -> raise (Failure "Not a valid function call")

and check_args (env : symbol_table) ((formals : var_decl list), (actuals : Ast.expr list)) = match (formals, actuals) with
    ([], []) -> []
  | (f_hd :: f_tl, a_hd :: a_tl) ->
      let f_type = (match f_hd with
                Var(t, _) -> t
              | Var_Init(t, _, _) -> t) in
      let (a_expr, a_type) = check_expr env a_hd in
                             if (f_type <> a_type) then raise (Failure "wrong argument type")
                             else (a_expr, a_type) :: check_args env (f_tl, a_tl)
  | (_, _) -> raise (Failure "wrong number of arguments")

let check_vtype (t : Ast.var_type) = match t with
    Int    -> Sast.Int
  | Double -> Sast.Double
  | String -> Sast.String
  | Bool   -> Sast.Boolean
  | Gram   -> Sast.Gram
  | _      -> raise (Failure "Variables cannot be of this type.")

let rec check_dup_vdecl (vname : string) (vars : Sast.var_decl list) = match vars with
    [] -> vname
  | hd :: tl -> (match hd with
                    Var(_, name) -> if(name = vname) then raise(Failure ("variable " ^ vname ^ " already declared"))
                                    else check_dup_vdecl vname tl
                  | Var_Init(_, name, _) -> if(name = vname) then raise(Failure ("variable " ^ vname ^ " already declared"))
                                            else check_dup_vdecl vname tl
                )

let check_vdecl (env : symbol_table) (v : Ast.var_decl) =
  (match v with
    Var(t, name) ->
      ignore(check_dup_vdecl name env.vars);
      let t = check_vtype t in Sast.Var(t, name)
  | Var_Init(t, name, expr) ->
      ignore(check_dup_vdecl name env.vars);
      let t = check_vtype t in
      let expr = check_expr env expr in
      let (_, t2 ) = expr in
      if t <> t2 then raise (Failure "Incorrect type for variable initialization") else Sast.Var_Init(t, name, expr))

let rec check_vdecl_list (env : symbol_table) (vl : Ast.var_decl list) = match vl with
    [] -> []
  | hd :: tl -> let checked_vdecl = check_vdecl env hd in
                checked_vdecl :: (check_vdecl_list { vars = (checked_vdecl :: env.vars); funcs = env.funcs; grams = env.grams } tl)

let rec check_stmt (env : symbol_table) (s : Ast.stmt) = match s with
    Block(sl) -> Sast.Block(check_stmt_list env sl)
  | Expr(e) -> Sast.Expr(check_expr env e)
  | Return(e) -> Sast.Return(check_expr env e)
  | If(e, s1, s2) ->
    let expr = check_expr env e in
    let (_, t) = expr in
    if t <> Sast.Boolean then
      raise (Failure "If statement uses a boolean expression")
    else
      let stmt1 = check_stmt env s1 in
      let stmt2 = check_stmt env s2 in
      Sast.If(expr, stmt1, stmt2)
  | For(e1, e2, e3, s) ->
    let ex1 = check_expr env e1 in
    let ex2 = check_expr env e2 in
    let (_, t) = ex2 in
    if t <> Sast.Boolean then
      raise (Failure "For statement uses a boolean expression")
    else
      let ex3 = check_expr env e3 in
      let stmt = check_stmt env s in
      Sast.For(ex1, ex2, ex3, stmt)
  | While(e, s) ->
    let expr = check_expr env e in
    let (_, t) = expr in
    if t <> Sast.Boolean then
      raise (Failure "While statement uses a boolean expression")
    else
      let stmt = check_stmt env s in
      Sast.While(expr, stmt)

and check_stmt_list (env : symbol_table) (sl : Ast.stmt list) = match sl with
    [] -> []
  | hd :: tl -> (check_stmt env hd) :: (check_stmt_list env tl)

let rec find_rtype (env : symbol_table) (body : Ast.stmt list) (rtype : Sast.var_type) = match body with
    [] -> rtype
  | hd :: tl -> (match hd with
      Return(e) -> if (rtype <> Sast.Void) then raise(Failure "function cannot have multiple return statements")
                   else let (_, t) = (check_expr env e) in find_rtype env tl t
    | _ -> find_rtype env tl rtype)

let sast_fdecl (env : symbol_table) (f : Ast.func_decl) =
  let checked_formals = check_vdecl_list env f.formals in
  let formals_env = { vars = env.vars @ checked_formals; funcs = env.funcs; grams = env.grams } in
  let checked_locals = check_vdecl_list formals_env f.locals in
  let new_env = { vars = formals_env.vars @ checked_locals; funcs = env.funcs; grams = env.grams } in
  { fname = f.fname; rtype = (find_rtype new_env f.body Sast.Void); formals = checked_formals; locals = checked_locals; body = (check_stmt_list new_env f.body) }

(* returns an updated func_decl with return type *)
let check_fdecl (env : symbol_table) (f : Ast.func_decl) = match f.fname with
    "main" -> (match f.formals with
        [] -> let sast_main = sast_fdecl env f in if (sast_main.rtype <> Sast.Void) then raise(Failure "main function should not return anything")
              else sast_main
      | _  -> raise(Failure "main function cannot have formal parameters"))
  | _ -> sast_fdecl env f

(* checks the list of function declarations in the program *)
let rec check_fdecl_list (env : symbol_table ) (fdecls : Ast.func_decl list) = match fdecls with
    []       -> raise(Failure "Valid FRAC program must have at least a main function")
  | hd :: [] -> if hd.fname <> "main" then raise(Failure "main function must be defined last")
                else (check_fdecl env hd) :: env.funcs
  | hd :: tl -> if (List.exists (fun func -> func.fname = hd.fname) env.funcs) then raise(Failure("function " ^ hd.fname ^ "() defined twice"))
                else match hd.fname with
                    "print" -> raise(Failure "reserved function name 'print'")
                  | "draw"  -> raise(Failure "reserved function name 'draw'")
                  | "grow"  -> raise(Failure "reserved function name 'grow'")
                  | "main"  -> raise(Failure "main function can only be defined once")
                  | _ -> check_fdecl_list { vars = env.vars; funcs = (check_fdecl env hd) :: env.funcs; grams = env.grams } tl

let rec find_rule (id : string) (rules : Ast.rule list) = match rules with
    [] -> raise(Failure "all elements of the alphabet must have corresponding rules")
  | hd :: tl -> (match hd with
                    Rec(c, rl) -> if(c = id) then c
                                  else find_rule id tl
                  | Term(c, t) -> if(c = id) then c
                                  else find_rule id tl)

let rec check_alphabet (checked : string list) (rules : Ast.rule list) (a : string list) = match a with
    [] -> []
  | hd :: tl -> if(List.mem hd checked) then raise(Failure "cannot have duplicates in alphabet")
                else let checked_c = find_rule hd rules in
                checked_c :: (check_alphabet (checked_c :: checked) rules tl)

let rec check_rule (a : string list) (i : string list) = match i with
    [] -> []
  | hd :: tl -> ignore(try List.find (fun id -> id = hd) a with Not_found -> raise(Failure "contains a rule not found in alphabet"));
                hd :: (check_rule a tl)

let check_turn_expr (e : Ast.expr) = match e with
    Int_lit(i) -> Sast.Int_lit(i)
  | Double_lit(d) -> Sast.Double_lit(d)
  | _ -> raise(Failure "turn functions must have argument of type int or double")

let check_move_expr (e : Ast.expr) = match e with
    Int_lit(i) -> Sast.Int_lit(i)
  | _ -> raise(Failure "move functions must have argument of type int")

let rec check_rules (recs : Sast.rule list) (terms : Sast.rule list) (a : string list) (rules : Ast.rule list) = match rules with
    []       -> recs, terms
  | hd :: tl -> (match hd with
                    Rec(c, rl) -> ignore(try List.find (fun id -> id = c) a with Not_found -> raise(Failure "rule not found in alphabet"));
                      ignore(if(List.exists (fun (rl : Sast.rule) -> match rl with
                          Rec(id, _) -> if(id = c) then true else false
                        | Term(_, _) -> false) recs) then raise(Failure "multiple recursive rules of the same name")
                      else check_rule a rl); let checked_rec = Sast.Rec(c, rl) in
                      check_rules (checked_rec :: recs) terms a tl
                  | Term(c, t) -> ignore(try List.find (fun id -> id = c) a with Not_found -> raise(Failure "rule not found in alphabet"));
                      if(List.exists (fun (t : Sast.rule) -> match t with
                          Term(id, _) -> if(id = c) then true else false
                        | Rec(_, _) -> false) terms) then raise(Failure "multiple terminal rules of the same name")
                      else let checked_t = (match t with
                          Rturn(e) -> Sast.Rturn(check_turn_expr e)
                        | Lturn(e) -> Sast.Lturn(check_turn_expr e)
                        | Move(e) -> Sast.Move(check_move_expr e)) in
                      let checked_term = Sast.Term(c, checked_t) in
                      check_rules recs (checked_term :: terms) a tl
                )

let check_gdecl (g : Ast.gram_decl) =
  let checked_alphabet = check_alphabet [] g.rules g.alphabet in
  let (checked_recs, checked_terms) = check_rules [] [] checked_alphabet g.rules in
  let checked_init = check_rule checked_alphabet g.init in
  { gname = g.gname; alphabet = checked_alphabet; init = checked_init; rec_rules = checked_recs; term_rules = checked_terms }

let rec check_gdecl_list (checked_gdecls : Sast.gram_decl list) (gdecls : Ast.gram_decl list) = match gdecls with
    [] -> checked_gdecls
  | hd :: tl -> if (List.exists (fun gram -> gram.gname = hd.gname) checked_gdecls) then raise(Failure("gram " ^ hd.gname ^ " defined twice"))
                else check_gdecl_list ((check_gdecl hd) :: checked_gdecls) tl

(* entry point *)
let check_program (prog : Ast.program) =
  let (gdecls, fdecls) = prog in
  let env = { vars = []; funcs = []; grams = [] } in
  let checked_gdecls = check_gdecl_list [] (List.rev gdecls) in
  let grams_env = { vars = env.vars; funcs = env.funcs; grams = checked_gdecls } in
  let checked_fdecls = check_fdecl_list grams_env (List.rev fdecls) in
  checked_gdecls, checked_fdecls</pre></div>

  <h3>8.5. SAST</h3>
  <code>sast.ml</code><br><br>
  <div class="highlight highlight-js"><pre>open Ast

(* Variable types *)
type var_type =
    Void
  | Int
  | Double
  | String
  | Boolean
  | Gram

(* Variable Declarations*)
and var_decl =
    Var of var_type * string
  | Var_Init of var_type * string * expression

and term =
    Rturn of expr
  | Lturn of expr
  | Move of expr

(* Rule Definitions *)
and rule =
    Rec of string * string list
  | Term of string * term

(* Grammar Declarations *)
and gram_decl = {
  gname : string;
  alphabet : string list;
  init : string list;
  rec_rules : rule list;
  term_rules : rule list;
}

(* Function Declarations *)
and func_decl = {
  fname: string;
  rtype: var_type;
  formals: var_decl list;
  locals: var_decl list;
  body: stmt list;
}

(* Expressions *)
and expr =
    Noexpr
  | Int_lit of int
  | Double_lit of float
  | Id of string
  | String_lit of string
  | Bool_lit of bool
  | ParenExpr of expression
  | Unop of op * expression
  | Binop of expression * op * expression
  | Assign of string * expression
  | Call of string * expression list

and expression = expr * var_type

(* Statements *)
and stmt =
    Expr of expression
  | Block of stmt list
  | Return of expression
  | If of expression * stmt * stmt
  | For of expression * expression * expression * stmt
  | While of expression * stmt


type program = gram_decl list * func_decl list</pre></div>

  <h3>8.6. Code Generator</h3>
  <code>compile.ml</code><br><br>
  
  <h3>8.7. FRAC</h3>
  <code>frac.ml</code><br><br>
  <div class="highlight highlight-js"><pre>type action = Semantic | Compile

(* Get the name of the program from the file name. *)
let get_prog_name source_file_path =
  let split_path = (Str.split (Str.regexp_string "/") source_file_path) in
  let file_name = List.nth split_path ((List.length split_path) - 1) in
  let split_name = (Str.split (Str.regexp_string ".") file_name) in
    List.nth split_name ((List.length split_name) - 2)

let _ =
  let name = get_prog_name Sys.argv.(1) in
  let path = Sys.getcwd() ^ "/" ^ name in
  let input = open_in Sys.argv.(1) in
  let lexbuf = Lexing.from_channel input in
  let program = Parser.program Scanner.token lexbuf in
  let (grams, funcs) = Semantic.check_program program in
  Compile.generate grams funcs path</pre></div>

</article>
</body>
</html>
